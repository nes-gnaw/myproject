# MapReduce笔记

### MR介绍

**MapReduce **：**用户编写的业务逻辑代码** 和 **自带默认组件** 整合成一个 **分布式运算程序**。



**优点：**  易于编程、良好的扩展性、高容错性、适合 PB 级以上海量数据的离线处理。

**缺点：** 不擅长实时计算、不擅长流式计算、不擅长 DAG（有向无环图）计算。



（1）MrAppMaster：负责整个程序的过程调度及状态协调。 

（2）MapTask：并发实例，完全并行运行，互不相干。 

（3）ReduceTask：并发实例互不相干，数据依赖于上一阶段的 MapTask 的输出。 



### MR原理

Hadoop 序列化：是把内存中的对象，转换成字节序列。

（1）紧凑 ：高效使用存储空间。 

（2）快速：读写数据的额外开销小。 

（3）互操作：支持多语言的交互。



**Shuffle 过程**

Map 方法之后，Reduce 方法之前的数据处理过程称之为 Shuffle。

（1）MapTask 收集 map()输出的 kv 对，放到内存缓冲区中。

（2）从缓冲区溢出本地磁盘文件，可能会溢出多个文件。

（3）多个溢出文件会被合并成大的溢出文件。

（4）溢出过程及合并过程中，调用 Partitioner 进行分区和针对 key 排序。

（5）ReduceTask 根据分区号，去各个 MapTask 机器上取分区数据。

（6）ReduceTask 抓取同一分区不同 MapTask 的结果文件，将这些文件再合并（归并排序） 

（7）合并成大文件后，Shuffle 的过程结束，后面进入 ReduceTask 逻辑运算过程（从文件中取出一个一个的键值对 Group，调用用户自定义的 reduce()方法）



**Shuffle优化**

（1）Shuffle 中的缓冲区大小会影响到 MapReduce 程序的执行效率，原则上说，缓冲区 越大，磁盘 io 的次数越少，执行速度就越快。 

（2）缓冲区的大小可以通过参数调整，参数：mapreduce.task.io.sort.mb 默认 100M。



**Partition 分区**

默认分区根据key的 **hashCode** 对 **ReduceTasks** 个数 **取模** 得到的。

自定义Partitioner步骤可实现自定义分区。



**分区的数量**

1. 过大导致产生空文件；

2. 过小导致数据无处安放，报错；

3. 等于1时，只会生成一个结果文件。

4. 分区号必须从零开始，逐一累加。



MapReduce默认按照 **字典顺序排序**，方法为 **快速排序**。



### MR深究



**Reduce Join**

**Map Join**

**数据清洗（ETL）**

**数据压缩**: 压缩可以在 MapReduce 任意阶段启用。

1. Gzip 压缩

​		优点：压缩率比较高； 

​		缺点：不支持 Split；压缩/解压速度一般； 

2. Bzip2 压缩

​		优点：压缩率高；支持 Split；

​		缺点：压缩/解压速度慢。 

3. Lzo 压缩

​		优点：压缩/解压速度比较快；支持 Split； 

​		缺点：压缩率一般；想支持切片需要额外创建索引。

4. Snappy 压缩

   优点：压缩和解压缩速度快； 

   缺点：不支持 Split；压缩率一般.